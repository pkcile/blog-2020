callbackFunction({"title":"Java学习-01-面向对象概念与多线程相关","sections":[{"title":"1.面向对象","steps":[{"title":"多态：一个接口，多种实现。java实现，重写、向上转型；@Override","content":"","code":"","note":""},{"title":"封装：最容易想到；private, get/set","content":"","code":"","note":""},{"title":"继承：extend；","content":"","code":"","note":""},{"title":"抽象：抽象类（不能被实例化）、接口；abstract, interface","content":"","code":"","note":""}]},{"title":"2.多线程、异步、返回值、线程安全","steps":[{"title":"1.定义线程池","content":"推荐的用法ThreadPoolExecutor","code":"        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                4,\n                4,\n                60,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(100),\n                new ThreadFactory() {\n                    private final AtomicLong threadIndex = new AtomicLong(0);\n                    @Override\n                    public Thread newThread(Runnable r) {\n                        Thread thread = new Thread(r);\n                        thread.setName(\"AsyncTaskThread-\" + threadIndex.getAndIncrement());\n                        return thread;\n                    }\n                },\n                new ThreadPoolExecutor.AbortPolicy());","note":"快捷定义，ExecutorService executor = Executors.newFixedThreadPool(4);"},{"title":"2.执行异步任务","content":"执行异步任务并回调获取值","code":"        Future<String> future = executor.submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                // 模拟耗时操作\n                Thread.sleep(2000);\n                return \"Hello from the asynchronous task!\";\n            }\n        });\nString result = future.get(); \n","note":"异步获取回调值， Future<String> future = executor.submit(new Callable<String>() {}"},{"title":"3.关闭线程池","content":"关闭线程池： executor.shutdown();","code":"","note":""},{"title":"4.场景1：定时异步任务框架集成方案","content":"","code":"使用Spring框架集成方案\n1.启动异步注解\n启动入口使用@EnableAsync\n@EnableScheduling\n@EnableAsync\n\n2.配置@Bean设置线程池配置\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.AsyncConfigurerSupport;\nimport org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\nimport java.util.concurrent.Executor;\n\n@Configuration\n@EnableAsync\npublic class AsyncConfig extends AsyncConfigurerSupport {\n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(25);\n        executor.setThreadNamePrefix(\"Define-Spring-Async-\");\n        executor.initialize();\n        return executor;\n    }\n}\n设置线程池的线程个数、核心线程、队列大小、名称\n3.定时任务使用异步注解\n@Async","note":""},{"title":"5.场景2：单例异步任务线程池","content":"长时间异步任务，订单、长请求调用\n超时：nginx默认有接口转发超时时间（三个超时时间）","code":"1.Runnable的使用\n// 方式1：直接绑定到Thread\nRunnable task = () -> System.out.println(\"Hello from thread\");\nnew Thread(task).start();\n\n// 方式2：提交到线程池\nExecutorService executor = Executors.newFixedThreadPool(2);\nexecutor.submit(task);\n\n2.单例的使用饿汉\n2.1 私有构造函数\nprivate AsyncTaskManager(...) { ... }\n\n2.2 静态全局访问点\npublic static AsyncTaskManager getInstance() {\n    return INSTANCE;\n}\n\n2.3 静态初始化实例\nprivate static final AsyncTaskManager INSTANCE = \n    new AsyncTaskManager(3, 6, 3600, 10);\n\n3.单例的使用特点\n饿汉式避免了多线程环境下首次获取实例时的同步开销，适合高频调用的场景\n静态内部类：利用类加载机制实现懒加载，线程安全且无锁\npublic class LazySingleton {\n    private LazySingleton() {}\n    private static class Holder {\n        static final LazySingleton INSTANCE = new LazySingleton();\n    }\n    public static LazySingleton getInstance() {\n        return Holder.INSTANCE;\n    }\n}","note":""}]}],"notes":[]});